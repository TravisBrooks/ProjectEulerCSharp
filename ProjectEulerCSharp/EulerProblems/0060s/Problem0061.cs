using System;
using System.Collections.Generic;
using System.Linq;

namespace ProjectEulerCSharp.EulerProblems._0060s
{
	[Euler(
			title: "Problem 61: Cyclical figurate numbers",
            description: @"The triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are generated by the following formulae:
            Tn=n(n+1)/2
            Sn=n^2
            Pn=n(3n-1)/2
            Hn=n(2n-1)
            Heptagonal: Hn=n(5n-3)/2
            Octagonal: On=n(3n-2)
            The ordered set of three 4-digit numbers with this property is:
            8128, 2882, 8281
            Find the sum of the only ordered set of six cyclic figurate numbers for which each number is a 4-digit number and all of them are different."
		)
	]
	// ReSharper disable once UnusedType.Global
	internal class Problem0061 : ISolution<int>
	{
		public bool HaveImplementedAnalyticSolution => false;

		public int BruteForceSolution()
		{
			var figurateNumbers = new List<FigurateNumberForChain>();
			GenerateFigurateNumbers(figurateNumbers, Triangle, FigurateType.Triangle);
			GenerateFigurateNumbers(figurateNumbers, Square, FigurateType.Square);
			GenerateFigurateNumbers(figurateNumbers, Pentagonal, FigurateType.Pentagonal);
			GenerateFigurateNumbers(figurateNumbers, Hexagonal, FigurateType.Hexagonal);
			GenerateFigurateNumbers(figurateNumbers, Heptagonal, FigurateType.Heptagonal);
			GenerateFigurateNumbers(figurateNumbers, Octagonal, FigurateType.Octagonal);

			figurateNumbers = figurateNumbers.Where(f => f.IsValid()).ToList();
			var figurateLookup = figurateNumbers.ToLookup(f => f.FirstTwoDigits);

			foreach (var figurateNumber in figurateNumbers)
			{
				var chain = TryToBuildChain(figurateLookup, [figurateNumber]);
				if (chain.Count == 6)
				{
					return chain.Sum(fn => fn.Number);
				}
			}

			return -1;
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="figurateNumbers">List that all the generated numbers are added to</param>
		/// <param name="figurateBuilder">fn to build numbers (ie Triangle, Square, etc...)</param>
		/// <param name="figurateType">Identifier for what type of figurate numbers are being generated</param>
		private static void GenerateFigurateNumbers(List<FigurateNumberForChain> figurateNumbers, Func<int, int> figurateBuilder, FigurateType figurateType)
		{
			var n = 1;
			var f = figurateBuilder(n);
			while (f < 10_000)
			{
				if (f >= 1000)
				{
					figurateNumbers.Add(FigurateNumberForChain.Build(f, figurateType));
				}
				n++;
				f = figurateBuilder(n);
			}
		}

		/// <summary>
		/// Recursion ftw!
		/// </summary>
		/// <param name="figurateLookup"></param>
		/// <param name="maybeCircle"></param>
		/// <returns></returns>
		private static List<FigurateNumberForChain> TryToBuildChain(
			ILookup<int, FigurateNumberForChain> figurateLookup,
			List<FigurateNumberForChain> maybeCircle)
		{
			var foundTypes = maybeCircle.Select(c => c.FigurateType).ToList();
			var foundNumbers = maybeCircle.Select(c => c.Number).ToList();
			var nextNumberKey = maybeCircle.Last().LastTwoDigits;
			// next number must have first 2 digits match last 2 digits of last number, be of a new FigurateType, and be unique
			var candidateNextNumbers = figurateLookup[nextNumberKey]
											.Where(fn => !foundTypes.Contains(fn.FigurateType)
												&& !foundNumbers.Contains(fn.Number))
											.ToList();
			foreach (var candidateNumber in candidateNextNumbers)
			{
				// if we have 5 the 6th must complete the circle back to the first number
				if (maybeCircle.Count == 5)
				{
					if (candidateNumber.LastTwoDigits == maybeCircle.First().FirstTwoDigits)
					{
						var completedCircle = new List<FigurateNumberForChain>(maybeCircle) { candidateNumber };
						return completedCircle;
					}
					continue;
				}
				var circleCopy = new List<FigurateNumberForChain>(maybeCircle) { candidateNumber };
				var result = TryToBuildChain(figurateLookup, circleCopy);
				// we have to check if the recursive TryToBuildChainImpl call found the happy path
				if (result.Count == 6)
				{
					return result;
				}
			}
			return [];
		}

		private static int Triangle(int n)
		{
			return n * (n + 1) / 2;
		}

		private static int Square(int n)
		{
			return n * n;
		}

		private static int Pentagonal(int n)
		{
			return n * (3 * n - 1) / 2;
		}

		private static int Hexagonal(int n)
		{
			return n * (2 * n - 1);
		}

		private static int Heptagonal(int n)
		{
			return n * (5 * n - 3) / 2;
		}

		private static int Octagonal(int n)
		{
			return n * (3 * n - 2);
		}

		public int AnalyticSolution()
		{
			throw new NotImplementedException();
		}

		public int ExpectedSolution()
		{
			return 28_684;
		}

		private enum FigurateType
		{
			Triangle,
			Square,
			Pentagonal,
			Hexagonal,
			Heptagonal,
			Octagonal
		}

		/// <summary>
		/// All the details you need to build a chain of figurate numbers.
		/// </summary>
		/// <param name="Number"></param>
		/// <param name="FirstTwoDigits"></param>
		/// <param name="LastTwoDigits"></param>
		/// <param name="FigurateType"></param>
		private record FigurateNumberForChain(int Number, int FirstTwoDigits, int LastTwoDigits, FigurateType FigurateType)
		{
			public static FigurateNumberForChain Build(int fourDigitNumber, FigurateType figurateType)
			{
				if (fourDigitNumber < 1000 || fourDigitNumber > 9999)
				{
					throw new ArgumentException("Four digit number expected", nameof(fourDigitNumber));
				}
				var firstTwoDigits = fourDigitNumber / 100;
				var lastTwoDigits = fourDigitNumber % 100;
				return new FigurateNumberForChain(fourDigitNumber, firstTwoDigits, lastTwoDigits, figurateType);
			}

			/// <summary>
			/// Verifies that the FirstTwoDigits and LastTwoDigits are in fact both 2 digit numbers. If there is a leading zero,
			/// (ie one half of a 4 digit number like 1203 is a single digit int) it is not valid.
			/// </summary>
			/// <returns></returns>
			public bool IsValid()
			{
				return FirstTwoDigits > 9 && LastTwoDigits > 9
					   && FirstTwoDigits < 100 && LastTwoDigits < 100;
			}
		}
	}
}
