using System;
using System.Collections.Generic;

namespace ProjectEulerCSharp.EulerProblems._0040s
{
    [Euler(
        title: "Problem 44: Pentagon Numbers",
        description: @"Pentagonal numbers are generated by the formula, Pn = n(3n - 1)/2. The first ten pentagonal numbers are:

            1, 5, 12, 22, 35, 51, 70, 92, 117, 145

It can be seen that P4 + p7 = 22 + 70 = 92 = P8. However, their difference, 70 - 22 - 48, is not pentagonal.

Find the pair of pentagonal numbers, Pj and Pk, for which their sum and difference are pentagonal and D = |Pk - Pj| is minimised; what is the value of D?")
    ]
    // ReSharper disable once UnusedMember.Global
    public class Problem0044 : ISolution<int>
    {
        public bool HaveImplementedAnalyticSolution => true;

        public int BruteForceSolution()
        {
            // I ran this a few times with a much bigger upper bound, I narrowed it down to 2500 to try and find a small value that worked
            var upperBound = 2_500;
            var pentagonals = new int[upperBound];
            for (var i = 0; i < upperBound; i++)
            {
                pentagonals[i] = Pentagonal(i+1);
            }
            // using this HashSet<int> to see if a number is in the pentagonals calculated is *much* faster
            var pantagonalLookup = new HashSet<int>(pentagonals);

            for (var j = 0; j < upperBound; j++)
            {
                var jPent = pentagonals[j];
                for (var k = 0; k < j; k++)
                {
                    var kPent = pentagonals[k];
                    var delta = jPent - kPent;
                    if (pantagonalLookup.Contains(delta))
                    {
                        if (pantagonalLookup.Contains(jPent + kPent))
                        {
                            return delta;
                        }
                    }
                }
            }

            return -1;
        }

        private static int Pentagonal(int n)
        {
            var num = n * (3 * n - 1);
            var p = num / 2;
            return p;
        }

        public int AnalyticSolution()
        {
            // Somewhat surprisingly the brute force solutions beats the snot out of this one.
            var j = 1;
            while (true)
            {
                var jPent = Pentagonal(j);
                var k = 1;
                while (k < j)
                {
                    var kPent = Pentagonal(k);
                    if (IsPentagonal(jPent + kPent))
                    {
                        var diff = jPent - kPent;
                        if (IsPentagonal(diff))
                        {
                            return diff;
                        }
                    }
                    k++;
                }
                j++;
            }
        }

        private static bool IsPentagonal(double maybePentagonal)
        {
            // This is just the inverted version of the pentagonal function. The steps I did to invert P(x) are:
            // x = (3y^2 - y)/2
            // 2x = 3y^2 - y
            // 0 = 3y^2 - y - 2x
            // Then I looked up ye old quadratic equation, plugged in the numbers and came up with 
            // y = (1 + √(24x + 1))/6
            // This inverted fn is continuous but we only care about the cases where it works out to an integer, indicating that the
            // passed in number is generated by Pentagonal(n)
            var num = 1 + Math.Sqrt(24 * maybePentagonal + 1);
            var n = num / 6;
            return Math.Abs(n - Math.Floor(n)) < 0.0001;
        }

        public int ExpectedSolution()
        {
            return 5_482_660;
        }
    }
}
